/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/proxy/Clones.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import './interfaces/IWrappedCollectionNFT.sol';

contract WrappedCollectionNFTProxy is Ownable {
    
    struct TokenInfo {
        string tokenName;
        string tokenSymbol;
        string description;
    }

    struct NFTPrice {
        uint256 collectionPrice;
        uint256 mintPrice;
    }

    struct RevenueAddress {
        address to;
        uint16 percentage;
    }
    
    address internal constant TREASURY = address(0xA9aE05943539DCb601d343aF9193Df17be0348E3);

    address public implementation;
    address private _collectionAddress;
    address[] public collectionList;
    RevenueAddress[] public revenueAddresses;

    event CollectionCreated(address _newCollection);
    
    constructor(address _implementation) {
        implementation = _implementation;
    }

    // Should be called at the first
    function addRevenueAddress(address _to, uint16 _percentage) public {
        RevenueAddress memory newRevenueAddress = RevenueAddress(_to, _percentage);
        revenueAddresses.push(newRevenueAddress);
    }

    function removeRevenueAddress(uint256 index) public {
        require(index < revenueAddresses.length, "Invalid index");

        // Move the last element to the index position
        revenueAddresses[index] = revenueAddresses[revenueAddresses.length - 1];

        // Remove the last element
        revenueAddresses.pop();
    }

    function createNewCollection(
        string calldata _name,
        string calldata _symbol,
        string calldata _description,
        uint256 _collectionPrice,
        uint256 _mintPrice,
        uint32 _iTotalSupply
    ) public returns (address newCollection) {
        newCollection = Clones.clone(implementation);

        TokenInfo memory tokenInfo = TokenInfo(_name, _symbol, _description);
        bytes memory tokenInfoEncodedData = abi.encode(tokenInfo);

        NFTPrice memory nftPrice = NFTPrice(_collectionPrice, _mintPrice);
        bytes memory nftPriceEncodedData = abi.encode(nftPrice);

        addRevenueAddress(msg.sender, 95_00); // default revenueAddress: mint price * 95% -> Owner
        bytes memory revenueArrayEncodedData = abi.encode(revenueAddresses);

        (bool success, ) = newCollection.call(
            abi.encodeWithSignature("initialize(bytes,bytes,uint32,bytes)", tokenInfoEncodedData, nftPriceEncodedData, _iTotalSupply, revenueArrayEncodedData)
        );

        require(success, "Creation Failed");

        collectionList.push(newCollection);
        _collectionAddress = newCollection;

        emit CollectionCreated(newCollection);
    }

    function mintNFTWithCollection(address _to, address _collection, uint256 _tokenId) public {
        IWrappedCollectionNFT(_collection).mint(_to, _tokenId);
    }

    function burnNFTWithCollection(address _collection, uint256 _tokenId) public {
        IWrappedCollectionNFT(_collection).burn(_tokenId);
    }

    function mintNFTForSequential(address _to, address _collection, uint32 _mintNum) public {
        uint32 collectionSize = getCollectionSize(_collection);
        
        require(_mintNum <= collectionSize, "Invalid mint number");

        uint32 i = 0; uint32 count = 0;
        while (i < collectionSize) {
            bool isMintedTokenId = exists(_collection, i);
            if (!isMintedTokenId) { // if token id i is not minted
                mintNFTWithCollection(_to, _collection, i);
                count++;
            }
            if (count == _mintNum) break;
            i++;
        }
    }

    function createCollectionNFT(
        string calldata _name,
        string calldata _symbol,
        string calldata _description,
        uint256 _collectionPrice,
        uint256 _mintPrice,
        uint32 _iTotalSupply, 
        address _to
    ) public returns (address newCollection) {
        // newCollection = createNewCollection(_name, _symbol, _description, _collectionPrice, _mintPrice, _iTotalSupply);
        mintNFTForSequential(_to, newCollection, _iTotalSupply);
    }

    function getCurrentCollection() public view returns (address) {
        return _collectionAddress;
    }

    function getCollectionList() public view returns (address[] memory) {
        return collectionList;
    }

    function getTokenName(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).name();
    }

    function getTokenSymbol(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).symbol();
    }

    function getBalanceOf(address _collection, address _owner) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).balanceOf(_owner);
    }

    function getOwnerOf(address _collection, uint256 _tokenId) public view returns (address) {
        return IWrappedCollectionNFT(_collection).ownerOf(_tokenId);
    }

    function exists(address _collection, uint256 _tokenId) public view returns (bool) {
        return IWrappedCollectionNFT(_collection).exists(_tokenId);
    }

    function getDescription(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).getDescription();
    }

    function getCollectionPrice(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getCollectionPrice();
    }

    function getMintPrice(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getMintPrice();
    }

    function getCollectionSize(address _collection) public view returns (uint32) {
        return IWrappedCollectionNFT(_collection).getCollectionSize();
    }

    function setCollection(address _collection) public {
        _collectionAddress = _collection;
    }
}




/*
    // ----------------------------- init function 
    // string memory tokenName,
    // string memory tokenSymbol,
    // description, //////////////////////////////////////////////////////
    // MintingType iMintingType,
    // bool isERC721,///////////////////////////////////
    // bool isUpgradeable,////////////////////////////////
    // address iErc20PaymentAddress,
    // uint256 iCollectionPrice, // ///////////////////////////  new 
    // InitialPrice initialPrice, // collection price, mint price
    // uint32 iTotalSupply,
    // uint16 iRoyaltyFee,
    // RevenueAddress[] calldata revenueAddresses,
    // bytes32 baseURICIDHash,
    // bytes32 placeholderImageCIDHash,
    // bool soulboundCollection



    // ------------------------ read function
    // tokenName,
    // tokenAddress, deployed time

    // token symbol,
    // description
    // create days (block number)
    // contract version 1000 (default)
    // collection minting page : https://sepolia-dog.testnet.nfts2.me/
    // minting type 
    // standard - erc721
    // current phase, public
    // mint price,
    // metadata fixed (not souldbound)
    // total supply
    // minted nft 
    // nfts left
    // Native coin (ethereum)
    // withdraw amount (price * count)
    // withdraw 
    // resale royalty

    // current owner


    // ----------------- Mint setting ---------------
    // update minting fee
    // update max per address
    // change phase - closed, presale, public, drop date, drop and end date
    
    // // --- earning ---------
    // creator fee enforcement, enable, disablke
*/