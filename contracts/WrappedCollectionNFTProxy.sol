/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "@openzeppelin/contracts/proxy/Clones.sol";
import {IWrappedCollectionNFT} from './interfaces/IWrappedCollectionNFT.sol';
import {IERC20} from './interfaces/IERC20.sol';

contract WrappedCollectionNFTProxy {

    enum MintingType { 
        SEQUENTIAL, 
        RANDOM, 
        SPECIFY, 
        CUSTOM_URI 
    }

    struct RevenueAddress {
        address to;
        uint16 percentage;
    }

    struct AirdropAddress {
        address to;
        uint32 amount;
    }

    address internal implementation;
    address internal wrap;
    address internal collectionAddress;
    uint256 internal collectionFee;
    address internal collectionFeeAddress;
    address[] private collectionList;

    event CollectionCreated(address _newCollection);
    event AffiliateSell(address indexed affiliate);

    function _requireOwner(address _collection, address _user) internal view {
        address owner = IWrappedCollectionNFT(_collection).getOwnerAddress();
        require(owner == _user, "Only collection owner(proxy side) can call this function");
    }

    constructor(address _implementation, address _wrap) {
        implementation = _implementation;
        wrap = _wrap;
    }
    
    /* params
        // tokenInfo - tokenName, tokenSymbol, description baseURICIDHash, placeholderImageCIDHash
        // nftFee - collectionFee, mintFee, royaltyFee
        // totalSupply
        // mintingType
        // revenueAddresses
        // soulboundCollection 
        // feeAddresses - collectionFeeAddress, mintFeeAddress, ownerAddress
    */
    function createNewCollection(
        string[] calldata tokenInfo,
        uint256[] calldata nftFee,
        uint32 totalSupply,
        MintingType mintingType,
        RevenueAddress[] memory revenueAddresses,
        bool soulboundCollection,
        address[] memory feeAddresses
    ) public returns (address newCollection) {
        newCollection = Clones.clone(implementation);
        
        collectionFee = nftFee[0];
        collectionFeeAddress = feeAddresses[0];
        IERC20(wrap).transferFrom(msg.sender, collectionFeeAddress, collectionFee); // 1. Receive collection fee from user 

        // get token information from tokenInfo array
        string memory tokenName = tokenInfo[0];
        string memory tokenSymbol = tokenInfo[1];
        string memory description = tokenInfo[2];
        string memory baseURICIDHash = tokenInfo[3];
        string memory placeholderImageCIDHash = tokenInfo[4];

        bytes memory nftFeeData = abi.encode(nftFee); // collectionFee, mintFee, royaltyFee
        uint32 iTotalSupply = totalSupply; // collection size
        bytes memory mintingTypeData = abi.encode(mintingType); // minting type (default: SEQUENTIAL)
        bytes memory revenueArrayEncodedData = abi.encode(revenueAddresses); // revenue address array
        bool iSoulboundCollection = soulboundCollection; // soulbound collection status
        bytes memory feeAddressesData = abi.encode(feeAddresses); // collectionFeeAddress, mintFeeAddress, ownerAddress
        
        // 2. create collection NFT
        (bool success1, ) = newCollection.call(
            abi.encodeWithSignature("initialize(string,string,string,bytes,bytes,string,string)", 
            tokenName,tokenSymbol,description,feeAddressesData,nftFeeData,baseURICIDHash,placeholderImageCIDHash)
        );
        require(success1, "Creation Part 1 Failed");

        (bool success2, ) = newCollection.call(
            abi.encodeWithSignature("mintInitialize(uint32,bytes,bytes,bool)", 
            iTotalSupply,mintingTypeData,revenueArrayEncodedData,iSoulboundCollection)
        );
        require(success2, "Creation Part 2 Failed");

        IWrappedCollectionNFT(newCollection).mint(msg.sender, 0); // 3. Mint collection NFT with token id 0 to new owner - msg.sender
        collectionAddress = newCollection;
        collectionList.push(newCollection); // insert new collection address to collection list

        emit CollectionCreated(newCollection);
    }
    
    /* params
        // tokenInfo - tokenName, tokenSymbol, description baseURICIDHash, placeholderImageCIDHash
        // nftFee - collectionFee, mintFee, royaltyFee
        // airdropInfo - (address, mintAmount) array
        // soulboundCollection - default: false (true - royalty fee disable)  
        // isMetadataFixed - default: true (false use placeholder URI hash instead of base URI hash)
        // feeAddresses - collectionFeeAddress, mintFeeAddress, ownerAddress        
    */
    function createCollectionMintNFT(
        string[] calldata tokenInfo,
        uint256[] calldata nftFee,
        AirdropAddress[] memory airdropInfo,
        bool soulboundCollection,
        address[] memory feeAddresses
    ) external returns (address newCollection) {
        uint32 _tokenAmount;
        for (uint256 i; i < airdropInfo.length; ) {
            _tokenAmount += airdropInfo[i].amount;
            unchecked {
                ++i;
            }
        }

        uint32 totalSupply = _tokenAmount;
        MintingType mintingType = MintingType.SEQUENTIAL;
        RevenueAddress[] memory revenueAddresses;
        
        newCollection = createNewCollection(tokenInfo, nftFee, totalSupply, mintingType, revenueAddresses, soulboundCollection, feeAddresses);
        airdropSequential(newCollection, airdropInfo, soulboundCollection);
    }

    // Sequential minting
    function mintNFTForSequential(address _collection, address to, uint256 amount) external payable {
        uint256 _mintPrice = IWrappedCollectionNFT(_collection).getMintPrice();
        uint256 totalPrice = _mintPrice * amount;

        _requirePayment(_mintPrice, amount); // check the eth balance
        
        IWrappedCollectionNFT(_collection).setWithdrawBalance(totalPrice);
        IWrappedCollectionNFT(_collection)._mintSequentialWithChecks(to, amount);
    }

    // Random minting
    function mintNFTForRandom(address _collection, address to, uint256 amount) external payable {
        uint256 _mintPrice = IWrappedCollectionNFT(_collection).getMintPrice();
        uint256 totalPrice = _mintPrice * amount;

        _requirePayment(_mintPrice, amount); // check the eth balance
        
        IWrappedCollectionNFT(_collection).setWithdrawBalance(totalPrice);
        IWrappedCollectionNFT(_collection)._mintRandomWithChecks(to, amount);
    }

    // Specify minting 
    function mintNFTForSpecify(address _collection, address to, uint256[] memory tokenIds) external payable {
        uint256 _mintPrice = IWrappedCollectionNFT(_collection).getMintPrice();
        uint256 amount = tokenIds.length;
        uint256 totalPrice = _mintPrice * amount;

        _requirePayment(_mintPrice, amount); // check the eth balance

        IWrappedCollectionNFT(_collection).setWithdrawBalance(totalPrice);
        IWrappedCollectionNFT(_collection)._mintSpecifyWithChecks(to, tokenIds);
    }

    function mintNFTForSequentialAffiliate(address _collection, address to, uint256 amount, address affiliate) external payable {
        _requirePaymentWithAffiliates(_collection, amount, affiliate);
        
        IWrappedCollectionNFT(_collection)._mintSequentialWithChecks(to, amount);
    }

    function mintNFTForRandomAffiliate(address _collection, address to, uint256 amount, address affiliate) external payable {
        _requirePaymentWithAffiliates(_collection, amount, affiliate);
        
        IWrappedCollectionNFT(_collection)._mintRandomWithChecks(to, amount);
    }

    function mintNFTForSpecifyAffiliate(address _collection, address to, uint256[] memory tokenIds, address affiliate) external payable {
        uint256 amount = tokenIds.length;
        _requirePaymentWithAffiliates(_collection, amount, affiliate);

        IWrappedCollectionNFT(_collection)._mintSpecifyWithChecks(to, tokenIds);
    }

    // free NFT minting send Airdrop sequential
    function airdropSequential(address _collection, AirdropAddress[] memory airdropInfo, bool soulbound) public {
        _requireOwner(_collection, msg.sender);
        bytes memory airdropArrayEncodedData = abi.encode(airdropInfo); // airdrop address array
        IWrappedCollectionNFT(_collection).airdropSequential(airdropArrayEncodedData, soulbound);
    }

    // free NFT minting send Airdrop random
    function airdropRandom(address _collection, AirdropAddress[] memory airdropInfo, bool soulbound) external {
        _requireOwner(_collection, msg.sender);
        bytes memory airdropArrayEncodedData = abi.encode(airdropInfo); // airdrop address array
        IWrappedCollectionNFT(_collection).airdropRandom(airdropArrayEncodedData, soulbound);
    }

    // free NFT minting send Airdrop specify 
    function airdropSpecify(address _collection, AirdropAddress[] memory airdropInfo, uint256[] memory tokenIds, bool soulbound) external {
         _requireOwner(_collection, msg.sender);
        bytes memory airdropArrayEncodedData = abi.encode(airdropInfo); // airdrop address array

        IWrappedCollectionNFT(_collection).airdropSpecify(airdropArrayEncodedData, tokenIds, soulbound);
    }

    function setMintFee(address _collection, uint256 newMintFee) external { // proxy contract
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).setMintPrice(newMintFee);
    }

    function setMaxPerAddress(address _collection, uint16 newMaxPerAddress) external { // proxy contract
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).setMaxPerAddress(newMaxPerAddress);
    }

    function setSalePhase(address _collection, IWrappedCollectionNFT.SalePhase salePhase, uint256 dropDateTimestamp, uint256 endDateTimestamp) external {
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).setSalePhase(salePhase, dropDateTimestamp, endDateTimestamp);
    }

    function mintPresale(address _collection, address to, uint256 amount) external payable {
        require(isWhitelisted(_collection, to), "Invalid whitelist user (proxy side)");

        IWrappedCollectionNFT.WhitelistAddress memory userWhitelist = getUserWhitelist(_collection, to);
        uint256 _mintPrice = userWhitelist.mintFee;
        uint256 totalPrice = _mintPrice * amount;

        _requirePayment(_mintPrice, amount); // check the eth balance
        
        IWrappedCollectionNFT(_collection).setWithdrawBalance(totalPrice);
        IWrappedCollectionNFT(_collection).mintPresale(to, amount);
    }

    function withdraw(address _collection) external {
        _requireOwner(_collection, msg.sender);
        uint256 withdrawBalance = IWrappedCollectionNFT(_collection).getWithdrawBalance();
        uint256 contractBalance = getBalance();

        require(withdrawBalance > 0, 'Current withdraw balance is 0!');
        require(contractBalance > 0, 'Current contract balance is 0!');
        require(contractBalance >= withdrawBalance, 'Insufficient contract balance!');

        IWrappedCollectionNFT.RevenueAddress[] memory revenuInfo = getRevenueAddressArray(_collection);

        for (uint256 i; i < revenuInfo.length; ) {
                uint256 _amount =  withdrawBalance * revenuInfo[i].percentage;
                uint256 amount = _amount / 10000; //  100.00 %
                address payable revenueAddress = payable(revenuInfo[i].to);

                bool success = revenueAddress.send(amount);
                require(success, "Failed to send Ether");

                unchecked {
                    ++i;
                }
            }

        IWrappedCollectionNFT(_collection).setWithdrawnAmount(withdrawBalance);
    }

    function affiliateWithdraw(address _collection, address payable affiliate) external {
        require(affiliate == msg.sender, "Valid affiliate can withdraw pending claim");

        uint256 pendingAffiliateBalance = IWrappedCollectionNFT(_collection).getPendingAffiliateBalance(affiliate);
        uint256 contractBalance = getBalance();

        require(pendingAffiliateBalance > 0, 'Current pending affiliate balance is 0!');
        require(contractBalance > 0, 'Current contract balance is 0!');
        require(contractBalance >= pendingAffiliateBalance, 'Insufficient contract balance!');

        bool success = affiliate.send(pendingAffiliateBalance);
        require(success, "Failed to send Ether");

        IWrappedCollectionNFT(_collection).setPendingAffiliateBalance(affiliate, pendingAffiliateBalance, true); // set pending affiliate amount, isWithdrawn true
    }

    function setCreatorFeeEnforcemented(address _collection, bool _isCreatorFeeEnforced) external {
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).setCreatorFeeEnforcemented(_isCreatorFeeEnforced);
    }

    function getCreatorFeeEnforcemented(address _collection) public view returns (bool) {
        return IWrappedCollectionNFT(_collection).getCreatorFeeEnforcemented();
    }

    function setAffiliatesPercentageAndDiscount(address _collection, uint16 userDiscount, uint16 affiliatePercentage, address affiliateAddress) external {
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).setAffiliatesPercentageAndDiscount(userDiscount, affiliatePercentage, affiliateAddress);
    }
    
    function getAffiliatesInfo(address _collection, address affiliateAddress) public view returns (bool enabled, uint16 userDiscount, uint16 affiliatePercentage) {
        return IWrappedCollectionNFT(_collection).getAffiliatesInfo(affiliateAddress);
    }

    function getImplementationAddress() public view returns (address) {
        return implementation;
    }

    function getWRAPAddress() public view returns (address) {
        return wrap;
    }

    function getCollectionContractAddress() public view returns (address) {
        return collectionAddress;
    }

    function getCollectionList() public view returns (address[] memory) {
        return collectionList;
    }

    function getOwnerAddress(address _collection) public view returns (address) {
        return IWrappedCollectionNFT(_collection).getOwnerAddress();
    }

    function getCreatedDate(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).createdDate();
    }

    function getTokenName(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).name();
    }

    function getTokenSymbol(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).symbol();
    }

    function getContractVersion(address _collection) public pure returns (uint) {
        return IWrappedCollectionNFT(_collection).getContractVersion();
    }

    function getMintingType(address _collection) public view returns (IWrappedCollectionNFT.MintingType) {
        return IWrappedCollectionNFT(_collection).getMintingType();
    }

    function getSalePhase(address _collection) public view returns (IWrappedCollectionNFT.SalePhase) {
        return IWrappedCollectionNFT(_collection).getSalePhase();
    }

    function getMintFee(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getMintPrice();
    }

    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed(address _collection) public view returns (bool) {
        return IWrappedCollectionNFT(_collection).isMetadataFixed();
    }

    function getCollectionSize(address _collection) public view returns (uint32) {
        return IWrappedCollectionNFT(_collection).collectionSize();
    }

    function getMintedAmount(address _collection) public view returns (uint32) {
        return IWrappedCollectionNFT(_collection).getMintedAmount();
    }

    function getLeftAmount(address _collection) public view returns (uint32) {
        return IWrappedCollectionNFT(_collection).getLeftAmount();
    }

    function getWithdrawBalance(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getWithdrawBalance();
    }

    function getWithdrawnAmount(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getWithdrawnAmount();
    }

    // return current collection affiliate balance for all affiliates 
    function getPendingTotalAffiliatesBalance(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getPendingTotalAffiliatesBalance();
    }

    function getPendingAffiliateBalance(address _collection, address affiliate) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getPendingAffiliateBalance(affiliate);
    }

    function getTotalCollectionBalance(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getTotalCollectionBalance();
    }

    function getRoyaltyFee(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).royaltyFee();
    }

    function getRoyaltyInfo(address _collection, uint256 salePrice) public view returns (address receiver, uint256 royaltyAmount) {
        return IWrappedCollectionNFT(_collection).royaltyInfo(salePrice);
    }

    function getMaxPerAddress(address _collection) public view returns (uint16) {
        return IWrappedCollectionNFT(_collection).getMaxPerAddress();
    }

    function getDropDate(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getDropDate();
    }

    function getEndDate(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getEndDate();
    }

    function getMintedTokenIds(address _collection, address owner) public view returns (uint256[] memory) {
        return IWrappedCollectionNFT(_collection).getMintedTokenIds(owner);
    }
    
    function getMintedTokenAmount(address _collection, address owner) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).getMintedTokenAmount(owner);
    }

    function getTotalMintedTokenIds(address _collection) public view returns (uint256[] memory) {
        return IWrappedCollectionNFT(_collection).getTotalMintedTokenIds();
    }

    function isWhitelisted(address _collection, address _user) public view returns (bool) {
        return IWrappedCollectionNFT(_collection).isWhitelisted(_user);
    }

    function getUserWhitelist(address _collection, address _user) public view returns (IWrappedCollectionNFT.WhitelistAddress memory) {
        return IWrappedCollectionNFT(_collection).getUserWhitelist(_user);
    } 

    // Function to receive Ether. msg.data must be empty
    receive() external payable {}

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function _requirePaymentWithAffiliates(address _collection, uint256 amount, address affiliate) internal {
        uint256 _mintPrice = getMintFee(_collection);
        (bool enabled, uint16 userDiscount, uint16 affiliatePercentage) = getAffiliatesInfo(_collection, affiliate); 
        (, uint16 userDiscount_0, uint16 affiliatePercentage_0) = getAffiliatesInfo(_collection, address(0)); 
        
        uint16 currentUserDiscount;
        uint16 currentAffiliatePercentage;
        if (enabled) {
            currentUserDiscount = userDiscount;
            currentAffiliatePercentage = affiliatePercentage;
        } else {
            currentUserDiscount = userDiscount_0;
            currentAffiliatePercentage = affiliatePercentage_0;
        }

        uint256 discountMintPrice = ((100 - currentUserDiscount) * _mintPrice) / 100;
        _requirePayment(discountMintPrice, amount);
        if (affiliate != address(0)) {
            uint256 affiliateAmount = (currentAffiliatePercentage * discountMintPrice * amount) / 100; // affiliate earning amount
            IWrappedCollectionNFT(_collection).setPendingAffiliateBalance(affiliate, affiliateAmount, false); // set pending affiliate amount, isWithdrawn false

            uint256 withdrawBalance = (discountMintPrice * amount) - affiliateAmount; // discountMintPrice * amount - discountMintPrice * amount * currentAffiliatePercentage
            IWrappedCollectionNFT(_collection).setWithdrawBalance(withdrawBalance); // set collection owner withdraw balance 
            
            emit AffiliateSell(affiliate);
        }
    }

    // Contract can't get user's eth balance directly, only check the sent value from user. In a word, it needs to user send exact eth amount using web3  
    function _requirePayment(uint256 p_mintPrice, uint256 amount) internal {
        require(msg.value == (p_mintPrice * amount), 'Invalid mint fee');
    }

    function burnNFTWithCollection(address _collection, uint256 _tokenId) external {
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).burn(_tokenId);
    }

    function getTokenURI(address _collection, uint256 tokenId) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection).getTokenURI(tokenId);
    }

    function getDescription(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection)._description();
    }

    function getBalanceOf(address _collection, address owner) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).balanceOf(owner);
    }

    function getOwnerOf(address _collection, uint256 _tokenId) public view returns (address) {
        return IWrappedCollectionNFT(_collection).ownerOf(_tokenId);
    }

    function exists(address _collection, uint256 _tokenId) public view returns (bool) {
        return IWrappedCollectionNFT(_collection).exists(_tokenId);
    }

    function getCollectionFee(address _collection) public view returns (uint256) {
        return IWrappedCollectionNFT(_collection).collectionPrice();
    }

    function getBaseURICIDHash(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection)._baseURICIDHash();
    }

    function getPlaceHolderImageCIDHash(address _collection) public view returns (string memory) {
        return IWrappedCollectionNFT(_collection)._placeholderImageCIDHash();
    }

    function getRevenueAddressArray(address _collection) public view returns (IWrappedCollectionNFT.RevenueAddress[] memory) {
        return IWrappedCollectionNFT(_collection).getRevenueAddressArray();
    }

    function getSoulBoundCollection(address _collection) public view returns (bool) {
        return IWrappedCollectionNFT(_collection)._soulboundCollection();
    }

    function getAirdropAddressArray(address _collection) public view returns (IWrappedCollectionNFT.AirdropAddress[] memory) {
        return IWrappedCollectionNFT(_collection).getAirdropAddressArray();
    }

    function getAffiliateSales(address _collection) public view returns (uint32) {
        return IWrappedCollectionNFT(_collection).getAffiliateSales();
    }

    function revealMetadata(address _collection, string memory baseURIHash) external {
        _requireOwner(_collection, msg.sender);
        IWrappedCollectionNFT(_collection).revealMetadata(baseURIHash);
    } 

    function setWhitelistInfo(address _collection, IWrappedCollectionNFT.WhitelistAddress[] memory whitelistInfo) external {
        _requireOwner(_collection, msg.sender);
        bytes memory whitelistEncodedData = abi.encode(whitelistInfo); // whitelist address array
        IWrappedCollectionNFT(_collection).setWhitelistInfo(whitelistEncodedData);
    }

    function getWhitelistInfo(address _collection) public view returns (IWrappedCollectionNFT.WhitelistAddress[] memory) {
        return IWrappedCollectionNFT(_collection).getWhitelistInfo();
    }
}
