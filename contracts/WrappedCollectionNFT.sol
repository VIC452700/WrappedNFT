/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
import { IERCStorage } from './interfaces/IERCStorage.sol';

contract WrappedCollectionNFT is Initializable, ERC721Upgradeable, EIP712Upgradeable, IERCStorage {

    address private _owner;
    address private _proxy;
    uint256 private _mintPrice; // direcet update part
    uint256 private _withdrawBalance; 
    uint256 private _withdrawnAmount; 
    uint16 private _maxPerAddress; // direct update part
    uint256 private _dropDateTimestamp; // direct update part
    uint256 private _endDateTimestamp; // direct update part
    bool private _isCreatorFeeEnforcemented; // direct update part
    uint256 internal _pendingTotalAffiliatesBalance; // direct update part
    uint32 internal _affiliateSalesTotalAmount; // direct update part

    address public collectionFeeAddress;
    address public mintFeeAddress;
    uint256 public collectionPrice;
    uint32 public collectionSize;
    uint256 public royaltyFee; // Max vaule 1000(10.00%)
    uint256 public createdDate;
    string public _description;
    string public _baseURICIDHash;
    string public _placeholderImageCIDHash;
    bool public _soulboundCollection;
    
    uint256[] internal _totalMintedTokenIds;
    uint256[] internal _totalUnmintedTokenIds;
    RevenueAddress[] private _revenueInfo;
    AirdropAddress[] private _airdropInfo;
    WhitelistAddress[] private _whitelistInfo;
    address[] private _affiliateArray;
    MintingType private _mintingType; // direct update part
    SalePhase private _currentPhase; // direct update part

    mapping(address => uint256[]) internal mintedTokenIds; // minted token id array per address
    mapping(address => uint256) internal mintedTokenAmount; // minted token amount per address
    mapping(uint256 => string) internal _tokenURIs;
    mapping(uint256 => bool) internal _soulbound;
    mapping(address => AffiliateInformation) internal _affiliatesInfo; // direct update part
    mapping(address => uint256) internal _pendingAffiliateBalance;
    mapping(address => WhitelistAddress) internal _userWhitelistInfo;
    mapping(address => uint32) internal _affiliateSales;

    modifier onlyOwner() {
        require(msg.sender == _owner || msg.sender == _proxy, "Only collection owner(collection side) can call this function");
        _;
    }
   
    function initialize(
        string calldata tokenName,
        string calldata tokenSymbol,
        string calldata description,
        bytes memory feeAddressesData,
        bytes memory nftFeeData,
        string calldata baseURICIDHash,
        string calldata placeholderImageCIDHash
    ) external initializer {
        __ERC721_init(tokenName, tokenSymbol);
        _description = description;

        address[] memory feeAddresses = abi.decode(feeAddressesData, (address[])); // collectionFeeAddress, mintFeeAddress, ownerAddress
        collectionFeeAddress = feeAddresses[0];
        mintFeeAddress = feeAddresses[1];
        _owner = feeAddresses[2];
        _proxy = msg.sender;

        uint256[] memory nftFee = abi.decode(nftFeeData, (uint256[])); // collectionPrice, _mintPrice, royaltyFee
        collectionPrice = nftFee[0];
        _mintPrice = nftFee[1];
        royaltyFee = nftFee[2];

        if (royaltyFee > 1000) revert RoyaltyFeeTooHigh(); // 10.00%
        if (bytes(baseURICIDHash).length != 0 && bytes(placeholderImageCIDHash).length != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (bytes(baseURICIDHash).length == 0) {
            if (bytes(placeholderImageCIDHash).length == 0) {
                // if (iMintingType != MintingType.CUSTOM_URI) // default MintingType - SEQUENTIAL
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }
        
        createdDate = block.timestamp;
    }

    function mintInitialize (
        uint32 iTotalSupply,
        bytes memory mintingTypeData,
        bytes memory revenueArrayEncodedData,
        bool soulboundCollection
    ) external {
        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();

        collectionSize = iTotalSupply;
        _mintingType = abi.decode(mintingTypeData, (MintingType));

        RevenueAddress[] memory revenueAddresses = abi.decode(revenueArrayEncodedData, (RevenueAddress[]));
        if (revenueAddresses.length > 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i < revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                _revenueInfo.push(revenueAddresses[i]); 
                unchecked {
                    ++i;
                }
            }
            if (revenuePercentageTotal > 10000) revert InvalidRevenuePercentage();
        }

        _soulboundCollection = soulboundCollection;
        _isCreatorFeeEnforcemented = true;

        // not minted token id array initialize
        for (uint256 i = 1; i <= collectionSize; i++) {
            _totalUnmintedTokenIds.push(i);
        }
    }

    function mint(address to, uint256 tokenId) public onlyOwner {
        _mint(to, tokenId);

        if (tokenId != 0) { // exclude token id 0
            _totalMintedTokenIds.push(tokenId);
            mintedTokenIds[to].push(tokenId);
            mintedTokenAmount[to]++;

            for (uint i = 0; i < _totalUnmintedTokenIds.length; i++) {
                if (_totalUnmintedTokenIds[i] == tokenId) {
                    _totalUnmintedTokenIds[i] = _totalUnmintedTokenIds[_totalUnmintedTokenIds.length - 1];
                    _totalUnmintedTokenIds.pop();
                }
            }
        }

        if (isMetadataFixed()) _setTokenURI(tokenId, _baseURICIDHash);
        else _setTokenURI(tokenId, _placeholderImageCIDHash);
    }

    function burn(uint256 tokenId) external onlyOwner {
        _burn(tokenId);
    }

     /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed() public view returns (bool) {
        return (bytes(_baseURICIDHash).length != 0 || (_mintingType == MintingType.CUSTOM_URI));
    }

    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {
        _tokenURIs[tokenId] = tokenURI;
    }

    function getTokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "Token id does not exist");
        string memory tokenURI = _tokenURIs[tokenId];
        return tokenURI;
    }

    function getRevenueAddressArray() public view returns (RevenueAddress[] memory) {
        return _revenueInfo;
    }

    function getAirdropAddressArray() public view returns (AirdropAddress[] memory) {
        return _airdropInfo;
    }

    function getWhitelistInfo() public view returns (WhitelistAddress[] memory) {
        return _whitelistInfo;
    }

    function setWhitelistInfo(bytes memory whitelistEncodedData) external onlyOwner {
        WhitelistAddress[] memory whitelistInfo = abi.decode(whitelistEncodedData, (WhitelistAddress[]));
        for (uint256 i; i < whitelistInfo.length; ) {
            _whitelistInfo.push(whitelistInfo[i]); 
            _userWhitelistInfo[whitelistInfo[i].to] = whitelistInfo[i]; // every user whitelist info store
            unchecked {
                ++i;
            }
        }
    }

    function isWhitelisted(address _user) public view returns (bool) {
        for (uint256 i; i < _whitelistInfo.length; ) {
            if (_whitelistInfo[i].to == _user) return true;

            unchecked {
                ++i;
            }
        }
        return false;
    }

    function getUserWhitelist(address _user) public view returns (WhitelistAddress memory) {
        require(isWhitelisted(_user), "Invalid whhitelist user");

        return _userWhitelistInfo[_user];
    }

    function getOwnerAddress() public view returns (address) {
        return _owner;
    }

    function getContractVersion() public pure returns (uint) {
        return 1000;
    }

    function exists(uint256 tokenId) public view returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    function getMintedAmount() public view returns (uint32) {
        uint32 count = 0;
        for (uint32 i = 1; i <= collectionSize; i++) {
            if (exists(i)) count++; 
        }
        return count;
    }

    function getLeftAmount() public view returns (uint32) {
        uint32 mintedNumber = getMintedAmount();
        return collectionSize - mintedNumber;
    }

    function getTotalMintedTokenIds() public view returns (uint256[] memory) {
        return _totalMintedTokenIds;
    }

    function getTotalUnmintedTokenIds() public view returns (uint256[] memory) {
        return _totalUnmintedTokenIds;
    }

    function setSalePhase(SalePhase salePhase, uint256 dropDateTimestamp, uint256 endDateTimestamp) external onlyOwner { // proxy contract
        _dropDateTimestamp = dropDateTimestamp;
        _endDateTimestamp = endDateTimestamp;
        _currentPhase = salePhase;
    }        

    function getSalePhase() public view returns (SalePhase) {
        return _currentPhase;
    }

    function getDropDate() public view returns (uint256) {
        return _dropDateTimestamp;
    }

    function getEndDate() public view returns (uint256) {
        return _endDateTimestamp;
    }

    function getMintingType() public view returns (MintingType) {
        return _mintingType;
    }

    function setMintPrice(uint256 newMintPrice) external onlyOwner { // proxy contract
        _mintPrice = newMintPrice;
    }

    function getMintPrice() public view returns (uint256) {
        return _mintPrice;
    }

    function setWithdrawBalance(uint256 amount) external onlyOwner {
        _withdrawBalance += amount;
    } 

    function setWithdrawnAmount(uint256 amount) external onlyOwner {
        _withdrawnAmount += amount;
        _withdrawBalance -= amount;
    } 

    function getWithdrawBalance() public view returns (uint256) {
        return _withdrawBalance;
    }

    function getWithdrawnAmount() public view returns (uint256) {
        return _withdrawnAmount;
    }

    function getTotalCollectionBalance() public view returns (uint256) {
        uint256 totalBalance = _withdrawBalance + _withdrawnAmount + _pendingTotalAffiliatesBalance;
        return totalBalance;
    }

    function setMaxPerAddress(uint16 newMaxPerAddress) external onlyOwner { // proxy contract
        require(newMaxPerAddress <= collectionSize, "Invalid maxPerAddress, Exceed collection size!");
        _maxPerAddress = newMaxPerAddress;
    }

    /// @notice Max amount of NFTs to be hold per address.
    function getMaxPerAddress() public view returns (uint16) {
        return _maxPerAddress;
    }

    function setCreatorFeeEnforcemented(bool _isCreatorFeeEnforced) external onlyOwner {
        _isCreatorFeeEnforcemented = _isCreatorFeeEnforced;
    }

    function getCreatorFeeEnforcemented() public view returns (bool) {
        return _isCreatorFeeEnforcemented;
    }

    function getMintedTokenIds(address owner) public view returns (uint256[] memory) {
        return mintedTokenIds[owner];
    }

    function getMintedTokenAmount(address owner) public view returns (uint256) {
        return mintedTokenAmount[owner];
    }

    function revealMetadata(string memory baseURIHash) external onlyOwner {
        _baseURICIDHash = baseURIHash;
    }

    function _checkPhase() internal {
        if (_currentPhase != SalePhase.PUBLIC) {
            if (_currentPhase == SalePhase.DROP_DATE) {
                if (block.timestamp >= _dropDateTimestamp) {
                    _currentPhase = SalePhase.PUBLIC;
                    delete(_dropDateTimestamp);
                } else {
                    revert WaitUntilDropDate();
                }
            } else if (_currentPhase == SalePhase.DROP_AND_END_DATE) {
                if (block.timestamp < _dropDateTimestamp) {
                    revert WaitUntilDropDate();
                }
                if (block.timestamp >= _endDateTimestamp) {
                    revert SaleFinished();
                }
            } else {
                revert PublicSaleNotOpen();
            }
        }
    }

    function _mintSequential(address to, uint256 amount) internal virtual {
        uint32 _soldTokens = getMintedAmount();
        for (uint256 i; i < amount; ) {
            unchecked {
                mint(to, ++_soldTokens);
                ++i;
            }
        }
    }

    function _mintSequential(address to, uint256 amount, bool soulbound) internal {
        uint32 _soldTokens = getMintedAmount();
        for (uint256 i; i < amount; ) {
            unchecked {
                mint(to, ++_soldTokens);

                if (soulbound) _soulbound[_soldTokens] = true;
                ++i;
            }
        }
    }

    function _mintSequentialWithChecks(address to, uint256 amount) external onlyOwner {
        _checkPhase();
        if (_mintingType != MintingType.SEQUENTIAL) revert InvalidMintingType();
        uint32 _soldTokens = getMintedAmount();

        if ((_soldTokens + amount) > collectionSize) revert CollectionSoldOut();
        if (_maxPerAddress != 0) {
            uint256 userMintedAmount = getMintedTokenAmount(to);
            if ((userMintedAmount + amount) > _maxPerAddress) revert MaxPerAddressExceeded();
        }

        _mintSequential(to, amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal override {
        if (
            from != address(0) &&
            (_soulbound[firstTokenId] || _soulboundCollection)
        ) revert NonTransferrableSoulboundNFT();

        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal override {
        super._afterTokenTransfer(from, to, firstTokenId, batchSize);

        if (_maxPerAddress != 0) {
            if (balanceOf(to) > _maxPerAddress) revert MaxPerAddressExceeded();
        }
    }

    function _randomTokenId(bytes32 seed, uint256 extraModifier) private view returns (uint256 tokenId) {
        tokenId = (uint256(keccak256(abi.encodePacked(seed, extraModifier))) % collectionSize) + 1;
        while (_exists(tokenId)) {
            unchecked {
                tokenId = (tokenId % collectionSize) + 1;
            }
        }
    }

    function _mintRandom(address to, uint256 amount, bytes32 seed, bool soulbound) private {
        for (; amount > 0; ) {
            uint256 tokenId = _randomTokenId(seed, amount);
            unchecked {
                mint(to, tokenId);

                if (soulbound) _soulbound[tokenId] = true;
                --amount;
            }
        }
    }

    function _mintRandomWithChecks(address to, uint256 amount) external onlyOwner {
        _checkPhase();
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();
        uint32 _soldTokens = getMintedAmount();
        if (_soldTokens + (amount) > collectionSize) revert CollectionSoldOut();
        if (_maxPerAddress != 0) {
            uint256 userMintedAmount = getMintedTokenAmount(to);
            if ((userMintedAmount + amount) > _maxPerAddress) revert MaxPerAddressExceeded();
        }
        
        uint256 blockNumberToReveal = block.number + 2;
        uint256 newBlockNumber = ((block.number & uint256(int256(-0x100))) + (blockNumberToReveal & 0xff));
        bytes32 seedFromBlockNumber = blockhash(newBlockNumber);

        _mintRandom(to, amount, seedFromBlockNumber, false);
    }

    function _mintSpecifyWithChecks(address to, uint256[] memory tokenIds) external onlyOwner {
        _checkPhase();
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();
        uint32 _soldTokens = getMintedAmount();
        if (_soldTokens + (tokenIds.length) > collectionSize) revert CollectionSoldOut();
        if (_maxPerAddress != 0) {
            uint256 userMintedAmount = getMintedTokenAmount(to);
            if ((userMintedAmount + tokenIds.length) > _maxPerAddress) revert MaxPerAddressExceeded();
        }

        _mintSpecify(to, tokenIds);
    }

    function _mintSpecify(address to, uint256[] memory tokenIds) internal virtual {
        uint256 inputLength = tokenIds.length;
        uint32 _soldTokens = getMintedAmount();
        unchecked {
            _soldTokens += uint32(inputLength);
        }
        for (uint256 i; i < inputLength; ) {
            uint256 tokenId = tokenIds[i];

            if (tokenId == 0 || tokenId > collectionSize) revert InvalidTokenId();
            unchecked {
                mint(to, tokenId);
                ++i;
            }
        }
    }

    function _mintSpecify(address to, uint256[] memory tokenIds, bool soulbound) private {
        _mintSpecify(to, tokenIds);
        uint256 inputLength = tokenIds.length;        
        if (soulbound) {
            for (uint256 i; i < inputLength; ) {
                _soulbound[tokenIds[i]] = true;
                unchecked {
                    ++i;
                }
            }
        }
    }

    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSequential(bytes memory airdropArrayEncodedData, bool soulbound) external onlyOwner {
        if (_mintingType != MintingType.SEQUENTIAL) revert InvalidMintingType();

        AirdropAddress[] memory airdropInfo = abi.decode(airdropArrayEncodedData, (AirdropAddress[]));
        uint32 _soldTokens = getMintedAmount();
        uint32 _tokenAmount;
        for (uint256 i; i < airdropInfo.length; ) {
            _tokenAmount += airdropInfo[i].amount;
            _airdropInfo.push(airdropInfo[i]); 

            if (_maxPerAddress != 0) {
                uint256 userMintedAmount = getMintedTokenAmount(airdropInfo[i].to);
                if ((userMintedAmount + airdropInfo[i].amount) > _maxPerAddress) revert MaxPerAddressExceeded();
            }

            unchecked {
                ++i;
            }
        }
        if (_soldTokens + _tokenAmount > collectionSize) revert CollectionSoldOut();

        for (uint256 i; i < airdropInfo.length; ) {
            for (uint256 j; j < airdropInfo[i].amount; ) {
                unchecked {
                    mint(airdropInfo[i].to, ++_soldTokens);
                    
                    if (soulbound) _soulbound[_soldTokens] = true;
                    ++j;
                }
            }
            ++i;
        }
    }

    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropRandom(bytes memory airdropArrayEncodedData, bool soulbound) external onlyOwner {
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();

        AirdropAddress[] memory airdropInfo = abi.decode(airdropArrayEncodedData, (AirdropAddress[]));
        uint32 _soldTokens = getMintedAmount();
        uint32 _tokenAmount;
        for (uint256 i; i < airdropInfo.length; ) {
            _tokenAmount += airdropInfo[i].amount;
            _airdropInfo.push(airdropInfo[i]); 

            if (_maxPerAddress != 0) {
                uint256 userMintedAmount = getMintedTokenAmount(airdropInfo[i].to);
                if ((userMintedAmount + airdropInfo[i].amount) > _maxPerAddress) revert MaxPerAddressExceeded();
            }

            unchecked {
                ++i;
            }
        }
        if ((_soldTokens + _tokenAmount) > collectionSize) revert CollectionSoldOut();

        bytes32 randomSeed = blockhash(block.number - 1);
        for (uint256 i; i < airdropInfo.length; ) {
            for (uint256 j; j < airdropInfo[i].amount; ) {
                unchecked {
                    uint256 newTokenId = _randomTokenId(randomSeed, j);
                    mint(airdropInfo[i].to, newTokenId);
                    
                    if (soulbound) _soulbound[newTokenId] = true;
                    ++j;
                }
            }
            ++i;
        }
    }

    function airdropSpecify(bytes memory airdropArrayEncodedData, uint256[] memory tokenIds, bool soulbound) external onlyOwner {
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();

        AirdropAddress[] memory airdropInfo = abi.decode(airdropArrayEncodedData, (AirdropAddress[]));
        uint32 _soldTokens = getMintedAmount();
        uint32 _tokenAmount;
        for (uint256 i; i < airdropInfo.length; ) {
            _tokenAmount += airdropInfo[i].amount;
            _airdropInfo.push(airdropInfo[i]); 

            if (_maxPerAddress != 0) {
                uint256 userMintedAmount = getMintedTokenAmount(airdropInfo[i].to);
                if ((userMintedAmount + airdropInfo[i].amount) > _maxPerAddress) revert MaxPerAddressExceeded();
            }
            
            unchecked {
                ++i;
            }
        }
        if (_soldTokens + (tokenIds.length) > collectionSize) revert CollectionSoldOut();
        if (_tokenAmount != tokenIds.length) revert InvalidInputSizesDontMatch(); // token amount must be tokenId array length

        uint256 tokenIdIndex = 0; // select first index of token Ids array 
        for (uint256 i; i < airdropInfo.length; ) {
            for (uint256 j; j < airdropInfo[i].amount; ) {
                unchecked {
                    if (tokenIds[tokenIdIndex] == 0 || tokenIds[tokenIdIndex] > collectionSize) revert InvalidTokenId();

                    mint(airdropInfo[i].to, tokenIds[tokenIdIndex]);
                    
                    if (soulbound) _soulbound[tokenIds[tokenIdIndex]] = true;
                    ++j;
                    ++tokenIdIndex;
                }
            }
            ++i;
        }
    }

    function transferCollectionOwnership(address newOwner) external onlyOwner {
        transferFrom(msg.sender, newOwner, 0);
        _owner = newOwner;
    }

    function isAffiliateAddress(address affiliate) public view returns (bool) {
        for (uint256 i = 0; i < _affiliateArray.length; i++) {
            if (_affiliateArray[i] == affiliate) return true;
        }
        return false;
    }

    function getAffiliatesAddressArray() public view returns (address[] memory) {
        return _affiliateArray;
    }

    function setAffiliatesPercentageAndDiscount(uint16 userDiscount, uint16 affiliatePercentage, address affiliateAddress) external onlyOwner {
        _affiliatesInfo[affiliateAddress].enabled = true;
        _affiliatesInfo[affiliateAddress].userDiscount = userDiscount;
        _affiliatesInfo[affiliateAddress].affiliatePercentage = affiliatePercentage;

        if (!isAffiliateAddress(affiliateAddress)) _affiliateArray.push(affiliateAddress);
    }

    function getAffiliatesInfo(address affiliateAddress) public view returns (bool enabled, uint16 userDiscount, uint16 affiliatePercentage) {
        enabled = _affiliatesInfo[affiliateAddress].enabled;
        userDiscount = _affiliatesInfo[affiliateAddress].userDiscount;
        affiliatePercentage = _affiliatesInfo[affiliateAddress].affiliatePercentage;
    }   

    function mintPresale(address to, uint256 amount) external onlyOwner {
        require(_currentPhase == SalePhase.PRESALE, "Presale is not activated");
        require(isWhitelisted(to), "Invalid whitelist user");
        require(_userWhitelistInfo[to].maxAmount >= amount, "Exceed your presale max amount.");

        uint32 _soldTokens = getMintedAmount();
        if (_soldTokens + amount > collectionSize) revert CollectionSoldOut();
        
        _mintSequential(to, amount, _userWhitelistInfo[to].soulbound);
    }

    function getPendingTotalAffiliatesBalance() public view returns (uint256) {
        return _pendingTotalAffiliatesBalance;
    }

    function getPendingAffiliateBalance(address affiliate) public view returns (uint256) {
        return _pendingAffiliateBalance[affiliate];
    }

    function setPendingAffiliateBalance(address affiliate, uint256 affiliateAmount, bool isWithdrawn) external onlyOwner {
        if (isWithdrawn) {
            _pendingTotalAffiliatesBalance -= affiliateAmount;
            _pendingAffiliateBalance[affiliate] -= affiliateAmount;
        } else {
            _pendingTotalAffiliatesBalance += affiliateAmount;
            _pendingAffiliateBalance[affiliate] += affiliateAmount;
        }
    }
    
    // get affiliate sales total amount 
    function getAffiliateSalesTotalAmount() public view returns (uint32) {
        return _affiliateSalesTotalAmount;
    }
    
    // get affiliate sales count number
    function getAffiliateSales(address affiliate) public view returns (uint32) { 
        return _affiliateSales[affiliate];
    }

    // increase the amount every affiliate sales
    function setAffiliateSales(address affiliate) external onlyOwner { 
        _affiliateSalesTotalAmount += 1;
        _affiliateSales[affiliate] += 1;
    }

    function royaltyInfo(uint256 salePrice) public view virtual returns (address receiver, uint256 royaltyAmount) {
        return (address(this), uint256((salePrice * royaltyFee) / 10000));
    }
}